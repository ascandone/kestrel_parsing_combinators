{"version":"0.0.1","modules":{"Int":{"moduleName":"Int","items":[{"type":"adt","name":"Int","params":[],"docComment":" An integer number\n"},{"type":"value","name":"+","signature":"Fn(Int, Int) -> Int","docComment":" Add two ints\n"},{"type":"value","name":"-","signature":"Fn(Int, Int) -> Int","docComment":" Substract two ints\n"},{"type":"value","name":"*","signature":"Fn(Int, Int) -> Int","docComment":" Multiply two ints\n"},{"type":"value","name":"/","signature":"Fn(Int, Int) -> Int","docComment":" Divide two ints\n"},{"type":"value","name":"^","signature":"Fn(Int, Int) -> Int","docComment":" Exponentiation\n \n ```kestrel\n 2 ^ 3 // => 8\n ```\n"},{"type":"value","name":"%","signature":"Fn(Int, Int) -> Int","docComment":" Modulo operator\n \n ```kestrel\n 10 % 2 // => 0\n 11 % 2 // => 1\n ```\n"}]},"Float":{"moduleName":"Float","items":[{"type":"adt","name":"Float","params":[],"docComment":" A floating point number.\n \n Infix operations that deal with `Float` follow the convention of having a trailing `.`\n This is necessary to distinguish them from `Int` operators\n"},{"type":"value","name":"+.","signature":"Fn(Float, Float) -> Float","docComment":" Add two floats\n"},{"type":"value","name":"-.","signature":"Fn(Float, Float) -> Float","docComment":" Substract two floats\n"},{"type":"value","name":"*.","signature":"Fn(Float, Float) -> Float","docComment":" Multiply two floats\n"},{"type":"value","name":"/.","signature":"Fn(Float, Float) -> Float","docComment":" Divide two floats\n"}]},"Bool":{"moduleName":"Bool","items":[{"type":"adt","name":"Bool","params":[],"docComment":" A boolean value that can either be `True` or `False`.\n \n Note that this isn't a builtin type, but a regular union type\n","variants":[{"name":"True","args":[]},{"name":"False","args":[]}]},{"type":"value","name":"&&","signature":"Fn(Bool, Bool) -> Bool","docComment":" Logic `and` between booleans\n \n ```kestrel\n True && True // => True\n True && False // => False\n False && True // => False\n False && False // => False\n ```\n"},{"type":"value","name":"||","signature":"Fn(Bool, Bool) -> Bool","docComment":" Logic `or` between booleans\n \n ```kestrel\n True && True // => True\n True && False // => True\n False && True // => True\n False && False // => False\n ```\n"},{"type":"value","name":"!","signature":"Fn(Bool) -> Bool","docComment":" Logic `not`\n \n ```kestrel\n !True // => False\n !False // => True\n ```\n"},{"type":"value","name":"==","signature":"Fn(a, a) -> Bool where a: Eq","docComment":" Perform structural equality between values.\n \n Requires values to implement the `Eq` trait, therefore\n equality is only supported for values of type:\n * `Int`\n * `Float`\n * `Char`\n * Union types whose constructors arguments support equality\n \n This mean that equality is supported, for example, for values of type `List<(String, Char)>`\n \n Equality between all the other values (for example functions or internal opaque types)\n is forbidden by the type system\n"},{"type":"value","name":"!=","signature":"Fn(a, a) -> Bool where a: Eq","docComment":" Same as `==`, but with negation\n"},{"type":"value","name":">","signature":"Fn(a, a) -> Bool where a: Ord"},{"type":"value","name":">=","signature":"Fn(a, a) -> Bool where a: Ord"},{"type":"value","name":"<","signature":"Fn(a, a) -> Bool where a: Ord"},{"type":"value","name":"<=","signature":"Fn(a, a) -> Bool where a: Ord"}]},"Char":{"moduleName":"Char","items":[{"type":"adt","name":"Char","params":[],"docComment":" A single `unicode`Â character.\n \n You can write chars with the `'` syntax, e.g. `'a'`\n (note the single quote, unlike in javascript)\n"},{"type":"value","name":"to_code","signature":"Fn(Char) -> Int"},{"type":"value","name":"from_code","signature":"Fn(Int) -> Char"}]},"Tuple":{"moduleName":"Tuple","items":[{"type":"adt","name":"Unit","params":[],"docComment":" `Unit` is a `Tuple` with zero values. It only has one value: `Unit`\n Can be used in a similar way to `undefined` in javascript, to represent values that do not\n actually bring any meaningful information\n \n For example:\n * You can use the type `Result<Unit, String>` to represent values that can either fail (with a `String` error message)\n or succeed, without yielding any particular value. This is more idiomatic that representing error as `Maybe<String>`\n * You can use the type `Task<Unit>` to represent a computation the doesn't yield any value. This is actually the type required by the `main` value\n \n **note** if you are trying to represent a value that can either be of the type `T` or undefined, `Maybe<T>` might be what you are looking for.\n","variants":[{"name":"Unit","args":[]}]},{"type":"adt","name":"Tuple2","params":["a","b"],"docComment":" A tuple containing 2 values\n","variants":[{"name":"Tuple2","args":["a","b"]}]},{"type":"value","name":"first","signature":"Fn((a, b)) -> a"},{"type":"value","name":"second","signature":"Fn((a, b)) -> b"},{"type":"adt","name":"Tuple3","params":["a","b","c"],"docComment":" A tuple containing 3 values\n","variants":[{"name":"Tuple3","args":["a","b","c"]}]},{"type":"adt","name":"Tuple4","params":["a","b","c","d"],"docComment":" A tuple containing 4 values\n","variants":[{"name":"Tuple4","args":["a","b","c","d"]}]}],"moduleDoc":" The `Tuple` module contains tuples utilities.\n A sintax sugar for writing tuples is available,\n e.g. `(\"a\", \"b\")` will desugar to `Tuple.Tuple2(\"a\", \"b\")` when used as a value, whereas\n `(Int, Float)` will desguar to `Tuple.Tuple2<Int, Float>` when used as a type.\n"},"Option":{"moduleName":"Option","items":[{"type":"adt","name":"Option","params":["a"],"docComment":" A type representing an value that might be either present (`Some`) or absent (`None`)\n","variants":[{"name":"Some","args":["a"]},{"name":"None","args":[]}]},{"type":"value","name":"map","signature":"Fn(Option<a>, Fn(a) -> b) -> Option<b>","docComment":" Maps the option's value using the given functions\n \n ```kestrel\n map(None, fn x { x + 1 }) // => None\n map(Some(42), fn x { x + 1 }) // => Some(43)\n ```\n"},{"type":"value","name":"and_then","signature":"Fn(Option<a>, Fn(a) -> Option<b>) -> Option<b>","docComment":" Maps the option's value using the given functions, and flattens the results\n \n It holds the property `and_then(x, Some) == x`\n ```kestrel\n and_then(None, fn x { Some(42) }) // => None\n and_then(Some(42), fn x { None }) // => None\n and_then(Some(42), fn x { Some(x + 1) }) // => Some(43)\n ```\n"},{"type":"value","name":"map2","signature":"Fn(Option<a>, Option<b>, Fn(a, b) -> c) -> Option<c>","docComment":" If both of the options are `Some`, maps their value using the\n given function. Else, returns `None`\n \n ```kestrel\n map2(None, None, fn a, b { a + b }) // => None\n map2(Some(42), None, fn a, b { a + b }) // => None\n map2(None, Some(42), fn a, b { a + b }) // => None\n map2(Some(1), Some(2), fn a, b { a + b }) // => Some(3)\n ```\n"},{"type":"value","name":"map3","signature":"Fn(Option<a>, Option<b>, Option<c>, Fn(a, b, c) -> d) -> Option<d>","docComment":" Like `map2`, but with 3 options\n"},{"type":"value","name":"with_default","signature":"Fn(Option<a>, a) -> a","docComment":" Returns wrapped value when option is `Some`, else returns the default value\n \n ```kestrel\n with_default(Some(\"value\"), \"default value\") // => \"value\"\n with_default(None, \"default value\") // => \"default value\"\n ```\n"}]},"List":{"moduleName":"List","items":[{"type":"adt","name":"List","params":["a"],"docComment":" This type represents a singly linked list\n","variants":[{"name":"Nil","args":[]},{"name":"Cons","args":["a","List<a>"]}]},{"type":"value","name":"range","signature":"Fn(Int, Int) -> List<Int>","docComment":" `range(a, b)` is a list from `a` to `b` exclusive\n \n ```kestrel\n range(0, 3) // => [0, 1, 2]\n ```\n"},{"type":"value","name":"map","signature":"Fn(List<a>, Fn(a) -> b) -> List<b>","docComment":" Applies the given function to every element of the list, and return a new list\n with the mapped elements.\n It takes `O(n)` time\n \n ```kestrel\n map([1, 2, 3], fn x { x * 10 }) // => [10, 20, 30]\n ```\n"},{"type":"value","name":"filter","signature":"Fn(List<a>, Fn(a) -> Bool) -> List<a>","docComment":" Returns a new list containing only the elements that match the given predicate, in the same order\n It takes `O(n)` time\n \n ```kestrel\n filter(['a', 'b', 'c'], fn x { x == 'b' }) // => ['b']\n ````\n"},{"type":"value","name":"map2","signature":"Fn(List<a>, List<b>, Fn(a, b) -> c) -> List<c>"},{"type":"value","name":"find","signature":"Fn(List<a>, Fn(a) -> Bool) -> Option<a>"},{"type":"value","name":"reduce","signature":"Fn(List<a>, b, Fn(b, a) -> b) -> b"},{"type":"value","name":"reduce_right","signature":"Fn(List<a>, b, Fn(a, b) -> b) -> b"},{"type":"value","name":"concat","signature":"Fn(List<a>, List<a>) -> List<a>"},{"type":"value","name":"sum_ints","signature":"Fn(List<Int>) -> Int"},{"type":"value","name":"flatten","signature":"Fn(List<List<a>>) -> List<a>"},{"type":"value","name":"flat_map","signature":"Fn(List<a>, Fn(a) -> List<b>) -> List<b>"},{"type":"value","name":"filter_map","signature":"Fn(List<a>, Fn(a) -> Option<b>) -> List<b>"},{"type":"value","name":"take","signature":"Fn(List<a>, Int) -> List<a>"},{"type":"value","name":"drop","signature":"Fn(List<a>, Int) -> List<a>"},{"type":"value","name":"is_empty","signature":"Fn(List<a>) -> Bool"},{"type":"value","name":"length","signature":"Fn(List<a>) -> Int"},{"type":"value","name":"zip","signature":"Fn(List<a>, List<b>) -> List<(a, b)>"},{"type":"value","name":"reverse","signature":"Fn(List<a>) -> List<a>","docComment":" Reverse a list.\n"},{"type":"value","name":"guard","signature":"Fn(Bool, Fn(Unit) -> List<a>) -> List<a>","docComment":" This function is meant to be used with `let#` syntax\n ```kestrel\n {\n   let#List.flat_map x = [1, 2];\n   let#List.flat_map y = ['a', 'b'];\n   let#List.guard _unit = x == 1;\n   [(x, y)]\n }\n ```\n"}]},"String":{"moduleName":"String","items":[{"type":"adt","name":"String","params":[],"docComment":" A value representing an unicode string\n"},{"type":"value","name":"++","signature":"Fn(String, String) -> String","docComment":" Concatenate two strings\n \n ```kestrel\n \"abc\" ++ \"def\" // => \"abcdef\"\n ```\n"},{"type":"value","name":"length","signature":"Fn(String) -> Int","docComment":" Returns the length of the string.\n It takes `O(1)` time\n \n ```kestrel\n length(\"abc\") // => 3\n ```\n"},{"type":"value","name":"char_at","signature":"Fn(String, Int) -> Option<Char>"},{"type":"value","name":"split","signature":"Fn(String, String) -> List<String>"},{"type":"value","name":"to_list","signature":"Fn(String) -> List<Char>"},{"type":"value","name":"from_char","signature":"Fn(Char) -> String","docComment":" Casts a `Char` into a `String`\n"},{"type":"value","name":"cons","signature":"Fn(Char, String) -> String"},{"type":"value","name":"parse_int","signature":"Fn(String) -> Option<Int>"},{"type":"value","name":"from_int","signature":"Fn(Int) -> String"}]},"Result":{"moduleName":"Result","items":[{"type":"adt","name":"Result","params":["a","err"],"docComment":" A type representing a value that could be either succesful or not.\n","variants":[{"name":"Ok","args":["a"]},{"name":"Err","args":["err"]}]},{"type":"value","name":"map","signature":"Fn(Result<a, b>, Fn(a) -> c) -> Result<c, b>","docComment":" Maps the result's `Ok` value using the given functions\n \n ```kestrel\n map(Ok(42), fn x { x + 1 }) // => Ok(43)\n map(Err(\"err\"), fn x { x + 1 }) // => Err(\"err\")\n ```\n"},{"type":"value","name":"map_err","signature":"Fn(Result<a, b>, Fn(b) -> c) -> Result<a, c>","docComment":" Like [`Result.map`](#map), but applies to the `Err` value\n"},{"type":"value","name":"and_then","signature":"Fn(Result<a, b>, Fn(a) -> Result<c, b>) -> Result<c, b>","docComment":" Maps the result's `Ok` value using the given functions, and flattens the results\n \n It holds the property `and_then(x, Ok) == x`\n ```kestrel\n and_then(Err(\"err\"), fn x { Ok(42) }) // => Err(\"err\")\n and_then(Err(\"err1\"), fn x { Err(\"err2\") }) // => Err(\"err2\")\n and_then(Ok(42), fn x { Err(\"err\") }) // => Err(\"err\")\n and_then(Ok(42), fn x { Ok(x + 1) }) // => Ok(43)\n ```\n"}]},"Task":{"moduleName":"Task","items":[{"type":"adt","name":"Task","params":["a"],"docComment":" A task represents a computation (either synchronous or asynchronous) that yiels a value of type `a`.\n Unlike javascript's `Promise`, creating a `Task` doesn't actually do anything.\n The only way to actually run the task is to assign it to the `main` function of the entrypoint module.\n\n Another difference from `Promise` is that `Task` doesn't encode failure:\n to represent a `Task` that might yield an error value you can use the `Task<Result<value, error>>` type.\n Also unlike `Promise`, a task might either be a synchronous operation or a microtask.\n"},{"type":"value","name":"of","signature":"Fn(a) -> Task<a>","docComment":" Lift a value into a `Task`.\n The resulting `Task` might be either synchronous or asynchronous (the behaviour is unspecified).\n"},{"type":"value","name":"never","signature":"Task<a>","docComment":" A task that never resolves.\n"},{"type":"value","name":"await","signature":"Fn(Task<a>, Fn(a) -> Task<b>) -> Task<b>","docComment":" Use the result of a `Task` to create a new `Task`. This function does not execute the `Task`, it only describes a new computation. It is the main primitive to (_sequentially_) chain computation.\n\n ```kestrel\n IO.readline\n |> Task.await(fn value {\n   IO.println(\"Input: \" ++ value)\n })\n ```\n"},{"type":"value","name":"map","signature":"Fn(Task<a>, Fn(a) -> b) -> Task<b>"},{"type":"value","name":"map_err","signature":"Fn(Task<Result<a, b>>, Fn(b) -> c) -> Task<Result<a, c>>","docComment":" If task is a `Result`, map error value.\n Equivalent of composing `Task.map` and `Result.map_err`\n"},{"type":"value","name":"sleep","signature":"Fn(Int) -> Task<Unit>","docComment":" Pause the execution for the given number of milliseconds\n"},{"type":"adt","name":"Id","params":[],"docComment":" Identifier of a forked `Task`.\n"},{"type":"value","name":"fork","signature":"Fn(Task<Unit>) -> Task<Id>","docComment":" Run the given computation concurrently.\n The `Id` is returned synchronously, thus there is no way to receive data from the forked `Task` or wait for it to finish.\n In order to accomplish that, the `MVar` synchronization primitive is provided in the `MVar` module.\n\n `fork` is a low-level primitive and you probably might want to use the higher-level `Async`Â module to perform concurrent computation.\n"},{"type":"value","name":"kill","signature":"Fn(Id) -> Task<Unit>","docComment":" Kill the computation with the given `Id`. Cancellation will be propagated recursively though its forks and awaited tasks.\n For example:\n ```kestrel\n pub let main = {\n   let#await task_id = Task.fork({\n     let#await _unit = Task.sleep(2000);\n     Task.println(\"Finished sleeping\")\n   });\n   // Killing this computation prevents the\n   // message to be printed\n   Task.kill(task_id)\n }\n ```\n \n Killing a terminated computation is a noop.\n"},{"type":"value","name":"await_ok","signature":"Fn(Task<Result<a, b>>, Fn(a) -> Task<Result<c, b>>) -> Task<Result<c, b>>"},{"type":"value","name":"none","signature":"Task<Unit>","docComment":" A task that does not do anything.\n Same as `Task.of(Unit)`.\n"},{"type":"value","name":"discard","signature":"Fn(Task<a>) -> Task<Unit>"},{"type":"value","name":"forever","signature":"Fn(Task<Unit>) -> Task<a>"}]},"Debug":{"moduleName":"Debug","items":[{"type":"value","name":"inspect","signature":"Fn(a) -> String where a: Show","docComment":" Convert any given value to a stringified version of it\n \n ```kestrel\n inspect(Just(42)) // => \"Just(42)\"\n ```\n"},{"type":"value","name":"todo","signature":"Fn(String) -> a","docComment":" You can use the `todo` function as a placeholder for future implementation.\n This will result in an runtime errors\n"},{"type":"value","name":"log","signature":"Fn(a, String) -> a where a: Show","docComment":" `console.log` some value with a label, and return the value\n As this function performs side effects outside the `Task` type, it won't be available on production development\n ```kestrel\n let x = Debug.log(42, \"my number\")\n // this logs `my number: 42`\n // and returns `42`\n ```\n"}],"moduleDoc":" Debugging utilities.\n \n This module is only meant to be used in development mode\n and it's not going to be supported in production mode\n"},"Expect":{"moduleName":"Expect","items":[{"type":"adt","name":"Expectation","params":[]},{"type":"value","name":"pass","signature":"Expectation","docComment":" An expectation that always passes\n"},{"type":"value","name":"fail","signature":"Fn(String) -> Expectation","docComment":" An expectation that always fails with the given reason\n"},{"type":"value","name":"equal","signature":"Fn(a, a) -> Expectation where a: Eq + Show","docComment":" Asserts that the given types are structurally equal. It uses `==` under the hood.\n"},{"type":"value","name":"ok","signature":"Fn(Result<a, b>) -> Expectation where a: Show, b: Show"},{"type":"value","name":"err","signature":"Fn(Result<a, b>) -> Expectation where a: Show, b: Show"},{"type":"value","name":"to_result","signature":"Fn(Expectation) -> Result<Unit, String>","docComment":" Converts the expectation to a result.\n This function is meant to be used internally\n"}]},"Parser":{"moduleName":"Parser","items":[{"type":"adt","name":"ParsingError","params":[],"variants":[{"name":"Expecting","args":["String"]}]},{"type":"adt","name":"Parser","params":["a"],"docComment":" Represents a parser that yields a value of type `a`\n"},{"type":"value","name":"run","signature":"Fn(Parser<a>, String) -> Result<a, ParsingError>","docComment":" Run the parser on the given string.\n"},{"type":"value","name":"of","signature":"Fn(a) -> Parser<a>","docComment":" A combinator that always succeeds with the given value\n"},{"type":"value","name":"fail","signature":"Fn(String) -> Parser<a>","docComment":" A combinator that always fails with the given reason\n"},{"type":"value","name":"try","signature":"Fn(Parser<a>) -> Parser<a>","docComment":" Avoid consuming the input if the parser fails. This is useful in combination with [`one_of`](#one_of)\n"},{"type":"value","name":"any","signature":"Parser<Char>","docComment":" A parser that consumes any char\n"},{"type":"value","name":"end","signature":"Parser<Unit>","docComment":" A parser that succeed on end of string\n"},{"type":"value","name":"and_then","signature":"Fn(Parser<a>, Fn(a) -> Parser<b>) -> Parser<b>","docComment":" Chains the result of a parser with a function that returns a new parser.\n Fails when one of the parsers fail\n \n If the first parse succeeds, the input is consumed even if the second parser fails\n"},{"type":"value","name":"map","signature":"Fn(Parser<a>, Fn(a) -> b) -> Parser<b>"},{"type":"value","name":"one_of","signature":"Fn(List<Parser<a>>) -> Parser<a>"},{"type":"value","name":"char","signature":"Fn(Char) -> Parser<Unit>","docComment":" Match an exact char\n"},{"type":"value","name":"satisfy","signature":"Fn(Fn(Char) -> Bool) -> Parser<Char>","docComment":" Only parse when predicate is true\n"},{"type":"value","name":"string","signature":"Fn(String) -> Parser<Unit>","docComment":" Match an exact string\n"},{"type":"value","name":"many","signature":"Fn(Parser<a>) -> Parser<List<a>>","docComment":" Runs the given parser _zero_ or more times, and return the list of parsed values\n"},{"type":"value","name":"many1","signature":"Fn(Parser<a>) -> Parser<(a, List<a>)>","docComment":" Runs the given parser _one_ or more times\n"},{"type":"value","name":"sep_by1","signature":"Fn(Parser<a>, Parser<b>) -> Parser<List<a>>","docComment":" List of _one_ or more values separated by given separator\n"},{"type":"value","name":"sep_by","signature":"Fn(Parser<a>, Parser<b>) -> Parser<List<a>>","docComment":" List of _zero_ or more values separated by given separator\n"},{"type":"value","name":"discard","signature":"Fn(Parser<a>) -> Parser<Unit>"}]},"IO":{"moduleName":"IO","items":[{"type":"value","name":"println","signature":"Fn(String) -> Task<Unit>"},{"type":"value","name":"print","signature":"Fn(String) -> Task<Unit>"},{"type":"value","name":"readline","signature":"Task<String>"},{"type":"value","name":"exit","signature":"Fn(Int) -> a"}]},"Time":{"moduleName":"Time","items":[{"type":"value","name":"now","signature":"Task<Int>"}]},"Test":{"moduleName":"Test","items":[{"type":"adt","name":"Test","params":[]},{"type":"value","name":"test","signature":"Fn(String, Fn() -> Expectation) -> Test","docComment":" Test the given expectation\n"},{"type":"value","name":"concat","signature":"Fn(List<Test>) -> Test","docComment":" Concat many tests\n"},{"type":"value","name":"describe","signature":"Fn(String, List<Test>) -> Test","docComment":" Wrap a test within a description\n"},{"type":"value","name":"run","signature":"Fn(Test) -> Task<Unit>","docComment":" Run the tests and print the tests result.\n Exits with the appropriate error code depending on the tests outcome\n"}],"moduleDoc":" This module contains functions used to create tests.\n You can create assertion using the `Expect` module.\n \n **note**: this module is temporary and will be removed from the `core` package\n"},"ParserTests":{"moduleName":"ParserTests","items":[{"type":"value","name":"main","signature":"Task<Unit>"}]},"MVar":{"moduleName":"MVar","items":[{"type":"adt","name":"MVar","params":["a"],"docComment":" A `MVar` is a synchronization primitives, useful for communicating from different forked tasks.\n Represents a mutable cell that can either be empty or filled with a value of type `a`.\n"},{"type":"value","name":"empty","signature":"Task<MVar<a>>","docComment":" Create an empty `MVar`\n"},{"type":"value","name":"put","signature":"Fn(MVar<a>, a) -> Task<Unit>","docComment":" Put a value into the given `MVar`.\n If the `MVar` is filled, it will block until it is possible to put.\n"},{"type":"value","name":"put_async","signature":"Fn(MVar<a>, a) -> Task<Id>","docComment":" Non-blocking version of `put`.\n Equivalent to wrapping a `put` inside a `Task.fork`\n"},{"type":"value","name":"take","signature":"Fn(MVar<a>) -> Task<a>","docComment":" Take the value from the given `MVar`.\n If the `MVar` is not filled, it will block until it is possible to take.\n"},{"type":"value","name":"of","signature":"Fn(a) -> Task<MVar<a>>","docComment":" Create a `MVar` filled with the given value.\n"},{"type":"value","name":"update_returning","signature":"Fn(MVar<a>, Fn(a) -> (b, a)) -> Task<b>"}]},"Async":{"moduleName":"Async","items":[{"type":"value","name":"both","signature":"Fn(Task<a>, Task<b>) -> Task<(a, b)>","docComment":" Run the two tasks concurrently and collect the results.\n\n ```kestrel\n pub let main = {\n   let#await (a, b) = Async.both(\n     Task.map(Task.sleep(1000), fn _ {\n       0\n     }),\n     Task.map(Task.sleep(1000), fn _ {\n       1\n     }),\n   );\n   // Resolves with a=0 and b=1\n   // in 1 second instead of 2\n   Task.none\n }\n ```\n"},{"type":"value","name":"all","signature":"Fn(List<Task<a>>) -> Task<List<a>>","docComment":" Like [both](#both), but for more than two tasks\n"},{"type":"value","name":"both_ok","signature":"Fn(Task<Result<a, b>>, Task<Result<c, b>>) -> Task<Result<(a, c), b>>","docComment":" Run the two `Task`s concurrently.\n Return `Ok` if both `Task`s succeeed, otherwise return `Err` with the first task that fails, and cancel the other.\n"},{"type":"value","name":"all_ok","signature":"Fn(List<Task<Result<a, b>>>) -> Task<Result<List<a>, b>>","docComment":" Like [both_ok](#both_ok), but for more than two tasks\n"},{"type":"value","name":"race","signature":"Fn(List<Task<a>>) -> Task<a>","docComment":" Run the tasks concurrently and yield the value of the first `Task` to complete.\n All the other tasks are cancelled.\n\n ```kestrel\n pub let main = {\n   let#await a = Async.race([\n     Task.map(Task.sleep(1000), fn _ {\n       0\n     }),\n     Task.map(Task.sleep(200), fn _ {\n       1\n     }),\n   ]);\n   // Resolves with a=1 in 200ms\n   Task.none\n }\n ```\n"}],"moduleDoc":" This module contains a bunch of utilities for handling concurrency operations\n"},"TestMain":{"moduleName":"TestMain","items":[{"type":"value","name":"main","signature":"Task<Unit>"}],"moduleDoc":" Internal module used for testing.\n This will be removed in future versions of this package\n"}}}